"use strict";(self.webpackChunkde_co_docs=self.webpackChunkde_co_docs||[]).push([[8147],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||a;return n?o.createElement(m,s(s({ref:t},u),{},{components:n})):o.createElement(m,s({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<a;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2430:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return d}});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),s=["components"],i={id:"ho-your-first-nft",title:"Lesson 5. Hands-On - Your first NFT",sidebar_position:6},l="Lesson 5: Hands-On - Your First NFT & Chained Txs",c={unversionedId:"into-the-woods/trail2-ergo-coding/ho-your-first-nft",id:"into-the-woods/trail2-ergo-coding/ho-your-first-nft",title:"Lesson 5. Hands-On - Your first NFT",description:"Aight, we've made big progress. Let's write some code to mint your first token. To make it a little more challenging, we will be using the NFT Creator Proxy Contract in Lesson 6 of trail one to make it a tad bit more fun.",source:"@site/docs/into-the-woods/trail2-ergo-coding/7-ho-your-first-nft.md",sourceDirName:"into-the-woods/trail2-ergo-coding",slug:"/into-the-woods/trail2-ergo-coding/ho-your-first-nft",permalink:"/deco-docs/docs/into-the-woods/trail2-ergo-coding/ho-your-first-nft",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"ho-your-first-nft",title:"Lesson 5. Hands-On - Your first NFT",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Lesson 4. Hands-On - Your First Token",permalink:"/deco-docs/docs/into-the-woods/trail2-ergo-coding/ho-your-first-token"},next:{title:"Trail 3: Multi-Stage Txs & Smart Contracts",permalink:"/deco-docs/docs/category/trail-3-multi-stage-txs--smart-contracts"}},u={},d=[{value:"What is a Chained Tx?",id:"what-is-a-chained-tx",level:2}],p={toc:d};function h(e){var t=e.components,n=(0,r.Z)(e,s);return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"lesson-5-hands-on---your-first-nft--chained-txs"},"Lesson 5: Hands-On - Your First NFT & Chained Txs"),(0,a.kt)("p",null,"Aight, we've made big progress. Let's write some code to mint your first token. To make it a little more challenging, we will be using the NFT Creator Proxy Contract in ",(0,a.kt)("a",{parentName:"p",href:"/deco-docs/docs/into-the-woods/trail1-eutxo-n-nfts/ho-designing-an-nft-creator-proxy-contract"},"Lesson 6 of trail one")," to make it a tad bit more fun."),(0,a.kt)("p",null,"Let's first pull up the contract that we have created in Lesson 6."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Injected Parameters\n"_tokenName" -> "DeCo Test Token"\n"_tokenDesc" -> "Random NFT for test"\n"_numOfDecimals" -> 0\n"_nftType" -> 1 (1 represents audio?)\n"_sha256HashOfFile" -> "{SHA OF FILE}"\n"_linkToArtwork" -> "https://lalala.co/lalala.png"\n\nval createNFTProxyContractScript: String = """{\n    val issuanceBox: Box = OUTPUTS(0)\n    val issuerBox: Box = INPUTS(0)\n    val outBoxIsArtistAddress: Boolean = issuanceBox.propositionBytes == issuerBox.R5[Coll[Byte]].get\n\n    val isRegistersDesiredValue: Boolean = {\n        allOf(Coll(\n            issuanceBox.R4[Coll[Byte]] == _tokenName,\n            issuanceBox.R5[Coll[Byte]] == _tokenDesc,\n            issuanceBox.R6[Long] == _numOfDecimals,\n            issuanceBox.R7[Long] == _nftType,\n            issuanceBox.R8[Coll[Byte]] == _sha256HashOfFile,\n            issuanceBox.R9[Coll[Byte]] == _linkToArtwork,\n        ))\n    }\n\n    sigmaProp(\n        outBoxIsArtistAddress &&\n        isRegistersDesiredValue)\n}"""\n')),(0,a.kt)("p",null,"What a beautiful masterpiece we have created. And the states."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Checkpoint"),(0,a.kt)("th",{parentName:"tr",align:null},"Address"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Start"),(0,a.kt)("td",{parentName:"tr",align:null},"Your Address")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Issuer Box"),(0,a.kt)("td",{parentName:"tr",align:null},"Undecided")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Issuance Box"),(0,a.kt)("td",{parentName:"tr",align:null},"Your Address")))),(0,a.kt)("p",null,"So a quick refresh. We have to first create the issuer box that has the proxy contract attached. Send the box to the blockchain. Then use that box to create the NFT."),(0,a.kt)("p",null,"In this example, we will introduce something called a chained transaction."),(0,a.kt)("h2",{id:"what-is-a-chained-tx"},"What is a Chained Tx?"),(0,a.kt)("p",null,"In the world of Ergo Blockchain. A block is mined every 2 minutes. This can be a waste of time if we engineered a ",(0,a.kt)("a",{parentName:"p",href:"/deco-docs/docs/into-the-woods/trail3-multi-stage-txs-n-contracts/k-what-is-a-multi-stage-tx"},"multi-stage tx"),". However, Ergo blockchain consist of a feature called chained tx that allows transaction to be chained from one to the other and all sent in one block. This allows transactions to scale parallelly. (As long as all the transaction succeeds)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Here's an example:"),"\nImagine, we have two transactions, TxA and TxB. Assuming these txs are more than just simple txs, but rather txs with smart contracts and conditions."),(0,a.kt)("p",null,"TxB is reliant on boxes in TxA. Meaning, if TxA is not executed, TxB cannot proceed, as there are no boxes that can be used as InputBoxes in TxB."),(0,a.kt)("p",null,"In other blockchain, you would have to submit TxA, wait for the block to mine, then process and submit TxB."),(0,a.kt)("p",null,"However, in Ergo, we can process and submit TxA. Retrieve the OutBoxes from TxA, compose TxB with the OutBoxes from TxA as InputBoxes, and then submit TxB to the blockchain. All in the same block."),(0,a.kt)("p",null,"Let's see it in action with our exercise."),(0,a.kt)("p",null,"First off, lets plan out our steps:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Create the ErgoClient"),(0,a.kt)("li",{parentName:"ol"},"Create the BlockchainContext"),(0,a.kt)("li",{parentName:"ol"},"Retrieve the transaction Input Boxes"),(0,a.kt)("li",{parentName:"ol"},"Create the Transaction Builder"),(0,a.kt)("li",{parentName:"ol"},"Compile Proxy Contract"),(0,a.kt)("li",{parentName:"ol"},"Create the IssuerBox with Proxy Contract"),(0,a.kt)("li",{parentName:"ol"},"Create the Prover"),(0,a.kt)("li",{parentName:"ol"},"Create Unsigned Transaction A"),(0,a.kt)("li",{parentName:"ol"},"Sign Transaction A and send to Blockchain"),(0,a.kt)("li",{parentName:"ol"},"Retrieve the OutBox from Transaction A"),(0,a.kt)("li",{parentName:"ol"},"Create IssuanceBox that is sent to User"),(0,a.kt)("li",{parentName:"ol"},"Mint Token"),(0,a.kt)("li",{parentName:"ol"},"Create the transaction with IssuanceBox"),(0,a.kt)("li",{parentName:"ol"},"Create Unsigned Transaction B"),(0,a.kt)("li",{parentName:"ol"},"Sign Transaction B and send to Blockchain")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'// 0. Create address\nval yourAddress: Address = Address.create("{Your wallet address}")\n\n// 1. Create the ErgoClient\nval ergoClient: ErgoClient = RestApiErgoClient.create(nodeApiUrl, networkType, nodeApiKey, explorerURL)\n\n// 2. Create the BlockchainContext\nergoClient.execute(ctx: BlockchainContext => {\n    // 3. Retrieve the transaction input box\n    // This input box will be your address.\n    // Therefore we have to pull boxes from your address.\n    val spendingBoxes: List[InputBox] = ctx.getDataSource.getUnspentBoxesFor(yourAddress, 0, 100)\n\n    // 4. Create the TransactionBuilder\n    val txB: UnsignedTransactionBuilder = ctx.newTxBuilder()\n\n    // 5. Compile Proxy Contract\n    val tokenName: String = "DeCo Test Token"\n    val tokenDesc: String = "Random NFT for test"\n    val numOfDecimals: Long = 0\n    val nftType = 1\n    val sha256OfFile = "{SHA of FILE}"\n    val linkToArtwork = "{Link to Artwork}"\n    val constants: List[(String, Any)] = List(\n        ("_tokenName", tokenName),\n        ("_tokenDesc", tokenDesc),\n        ("_numOfDecimals", numOfDecimals),\n        ("_nftType", nftType),\n        ("_sha256HashOfFile", sha256OfFile),\n        ("_linkToArtwork", linkToArtwork)\n    )\n    val builder: ConstantsBuilder = new ConstantsBuilder\n    val ergoConstants: Constants = {\n        constants.foreach(c => builder.item(c._1, c._2))\n        builder.build()\n    }\n    val nftCreatorProxyContract: ErgoContract = ctx.compileContract(\n        ergoConstants,\n        // This is the string from above\n        createNFTProxyContractScript\n    )\n\n    // 6. Create the IssuerBox with ProxyContract\n    val issuerBox: OutBox = txB\n      .outBoxBuilder()\n      // Declare value of the OutBox\n      // We need 2*MinFee because the\n      // proxy contract needs enough\n      // funds to be processed\n      .value(2*ErgCommons.MinBoxFee)\n      // Send back to your address\n      .contract(nftCreatorProxyContract)\n      .build()\n\n\n    // 7. Create the Prover\n    val prover: ErgoProver = ctx.newProverBuilder()\n        .withMnemonic(\n            SecretString.create(BuyerMnemonic),\n            SecretString.empty()\n        )\n        .build();\n\n    // 8. Create the unsigned transaction\n    val unsignedIssuerBoxTx: UnsignedTransaction = txBuilder.boxesToSpend(spendingBoxes)\n        .outputs(issuerBox)\n        .fee(Parameters.MinFee)\n        .sendChangeTo(yourAddress.getErgoAddress)\n        .build();\n\n    // 9. Sign and Send TxA\n    val signedTxA: SignedTransaction = prover.sign(unsignedIssuerBoxTx)\n    val txIdA: String = ctx.sendTransaction(signedTxA)\n\n    // 10. Retrieve the OutBox from Transaction A\n    val outputsToSpend: List[InputBox] = signedTxA.getOutputsToSpend\n\n    val issuerBoxAsInputBox: InputBox = outputsToSpend.get(0)\n\n    // 11. Create IssuanceBox that is sent to User\n    val issuanceBox: OutBox = txB\n      .outBoxBuilder()\n      // Declare value of the OutBox\n      .value(ErgCommons.MinBoxFee)\n      // Mint token in OutBox\n      .mintToken(eip4Token(tokenToMint))\n      // Send back to your address\n      .contract(yourAddress)\n      .build()\n\n    // 12. Mint Token\n    val tokenToMint: ErgoToken = new Eip4Token(\n            issuerBoxAsInputBox.getId.toString,\n            1,\n            tokenName,\n            tokenDesc,\n            numOfDecimals,\n            ErgoValue.of(nftType),\n            ErgoValue.of(sha256OfFile),\n            ErgoValue.of(linkToArtwork)\n        )\n\n    // 14. Create Unsigned Transaction B\n    val unsignedIssuanceTx: UnsignedTransaction = txBuilder.boxesToSpend(issuerBoxAsInputBox)\n        .outputs(issuanceBox)\n        .fee(Parameters.MinFee)\n        .sendChangeTo(yourAddress.getErgoAddress)\n        .build();\n\n    // 15. Sign Transaction B and send to Blockchain\n    val signedTxB: SignedTransaction = prover.sign(unsignedIssuanceTx)\n    val txIdB: String = ctx.sendTransaction(signedTxB)\n})\n')))}h.isMDXComponent=!0}}]);