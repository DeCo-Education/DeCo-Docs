"use strict";(self.webpackChunkde_co_docs=self.webpackChunkde_co_docs||[]).push([[7492],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(n),h=o,m=u["".concat(s,".").concat(h)]||u[h]||d[h]||i;return n?a.createElement(m,l(l({ref:t},p),{},{components:n})):a.createElement(m,l({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,l[1]=r;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5089:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return d}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),l=["components"],r={id:"t-Ergo Syntax",title:"Tips - Ergo Syntax",sidebar_position:0},s="Basic Syntax In ErgoScript",c={unversionedId:"into-the-woods/trail2-ergo-coding/t-Ergo Syntax",id:"into-the-woods/trail2-ergo-coding/t-Ergo Syntax",title:"Tips - Ergo Syntax",description:"What\u2019s going on here?",source:"@site/docs/into-the-woods/trail2-ergo-coding/1-t-ergo-syntax.md",sourceDirName:"into-the-woods/trail2-ergo-coding",slug:"/into-the-woods/trail2-ergo-coding/t-Ergo Syntax",permalink:"/deco-docs/docs/into-the-woods/trail2-ergo-coding/t-Ergo Syntax",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{id:"t-Ergo Syntax",title:"Tips - Ergo Syntax",sidebar_position:0},sidebar:"tutorialSidebar",previous:{title:"DApp Components - Backend",permalink:"/deco-docs/docs/into-the-woods/trail2-ergo-coding/dapp-components"},next:{title:"WIP Lesson 1. Knowledge - Env Set Up (Scala)",permalink:"/deco-docs/docs/into-the-woods/trail2-ergo-coding/k-development-env-set-up-scala"}},p={},d=[{value:"Learn to think in true and false statements, booleans (More specifically, Sigma Propositions) are the core of every ErgoScript contract",id:"learn-to-think-in-true-and-false-statements-booleans-more-specifically-sigma-propositions-are-the-core-of-every-ergoscript-contract",level:3},{value:"More ErgoScript Syntax Examples:",id:"more-ergoscript-syntax-examples",level:2},{value:"Def vs Val?",id:"def-vs-val",level:3},{value:"Sigma Propositions",id:"sigma-propositions",level:2},{value:"SigmaProps From Booleans",id:"sigmaprops-from-booleans",level:3},{value:"SigmaProps From Public Keys",id:"sigmaprops-from-public-keys",level:3},{value:"SigmaProp Operations",id:"sigmaprop-operations",level:3},{value:"Pin-lock Contract",id:"pin-lock-contract",level:3},{value:"Pin-lock Contract (with SELF)",id:"pin-lock-contract-with-self",level:3},{value:"HEIGHT",id:"height",level:3},{value:"SELF",id:"self",level:3},{value:"INPUTS",id:"inputs",level:3},{value:"Data Inputs",id:"data-inputs",level:3},{value:"OUTPUTS",id:"outputs",level:3},{value:"Headers",id:"headers",level:3},{value:"Pre-Headers",id:"pre-headers",level:3},{value:"Example",id:"example",level:2},{value:"R0",id:"r0",level:3},{value:"R1",id:"r1",level:3},{value:"R2",id:"r2",level:3},{value:"R3",id:"r3",level:3},{value:"R4 - R9",id:"r4---r9",level:3},{value:"Other Box Functions",id:"other-box-functions",level:3},{value:"Example",id:"example-1",level:2},{value:"Logical Functions",id:"logical-functions",level:2},{value:"AllOf",id:"allof",level:3},{value:"AnyOf",id:"anyof",level:3},{value:"XorOf",id:"xorof",level:3},{value:"Zero-Knowledge Functions",id:"zero-knowledge-functions",level:2},{value:"AtLeast",id:"atleast",level:3},{value:"ZKProof",id:"zkproof",level:3},{value:"Cryptographic Functions",id:"cryptographic-functions",level:2},{value:"Blake2b256",id:"blake2b256",level:3},{value:"Sha256",id:"sha256",level:3},{value:"DecodePoint",id:"decodepoint",level:3},{value:"ProveDHTuple",id:"provedhtuple",level:3},{value:"ProveDLog",id:"provedlog",level:3},{value:"Compile-Time Functions",id:"compile-time-functions",level:2},{value:"FromBase",id:"frombase",level:3},{value:"PK",id:"pk",level:3},{value:"Deserialize",id:"deserialize",level:3},{value:"Other Functions",id:"other-functions",level:2},{value:"GetVar",id:"getvar",level:3},{value:"SubstConstants",id:"substconstants",level:3},{value:"Example: Alcohol Sale Proxy Contract",id:"example-alcohol-sale-proxy-contract",level:2},{value:"Helpful article:",id:"helpful-article",level:3}],u={toc:d};function h(e){var t=e.components,n=(0,o.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"basic-syntax-in-ergoscript"},"Basic Syntax In ErgoScript"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text",metastring:'title="Completion Status"',title:'"Completion','Status"':!0},"Version: 1st Version\nWritten by: LGD\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val bool: Boolean = true\n\n")),(0,i.kt)("p",null,"What\u2019s going on here?"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"val")," - A keyword used to create a basic, immutable, value of any type"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"bool")," - The name used for the value created"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},": Boolean")," - Specifying the type of the value, this is not always necessary, but does make code more understandable"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"= true")," - We are setting our Boolean value bool equal to true"),(0,i.kt)("p",null,"ErgoScript is strongly typed, you should always know what types you are dealing with"),(0,i.kt)("h3",{id:"learn-to-think-in-true-and-false-statements-booleans-more-specifically-sigma-propositions-are-the-core-of-every-ergoscript-contract"},"Learn to think in true and false statements, booleans (More specifically, Sigma Propositions) are the core of every ErgoScript contract"),(0,i.kt)("h2",{id:"more-ergoscript-syntax-examples"},"More ErgoScript Syntax Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  if(bool == true){\n    val x = 0\n    val y = 1\n    val z = ((x * y) + 5) - (3 / 2)\n  }else{\n    val x = 2L\n    val y: Coll[Long]  = Coll(0L, 1L, x) // You can build collections of elements\n    val z: (Long, Long) = (3, 4)\n    val a: (Long, Coll[Long]) = (x, y) // Build complex types by layering together pairs and colls\n    val b: Coll[((Long, Long), Boolean)] = Coll(((2L, 4L), true), ((7L, 2L), false))\n  }\n\n")),(0,i.kt)("p",null,"ErgoScript is based off of Scala, which means we have some standard functional programming methods and syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  val myMap: Coll[(Int, Long)] = {      // Wrap this val statement into a function that returns a collection of integers paired with longs\n    val intCollection = Coll(0, 1, 2)\n    intCollection.map{                  // Use the map function, a standard FP method that iterates through the entire\n      (myInt: Int) =>                   // collection and inputs each element through a function to return a collection of outputs.\n        (myInt, myInt.toLong)           // We represent our mapping function using a Lambda expression, we define the\n                                        // parameter to be the element of our collection (an Int), then use the\n                                        // arrow operator (=>) in order to show how our parameter maps to an output.\n    }                                   // We do not need to specify the return value with a keyword\n  }\n\n")),(0,i.kt)("h3",{id:"def-vs-val"},"Def vs Val?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"\n  def computeAsDef(myInt: Int): Int = {\n    myInt + 1\n  }\n\n  val computeAsVal: Int = {\n    (myInt: Int) =>\n      myInt + 1\n  }\n\n")),(0,i.kt)("p",null,"The above statements ",(0,i.kt)("strong",{parentName:"p"},"do the exact same thing"),". The difference is that ",(0,i.kt)("inlineCode",{parentName:"p"},"val")," statements are calculated when the script initializes itself to be run. ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," statements are instead calculated whenever the call is made.\nIn most instances, you will likely use ",(0,i.kt)("inlineCode",{parentName:"p"},"val")," statements"),(0,i.kt)("h2",{id:"sigma-propositions"},"Sigma Propositions"),(0,i.kt)("p",null,"Sigma Propositions are the core of every single ErgoScript contract\nSigmaProps represent some conditions about the transaction that must be met in order to spend a certain box.\nThey are quite similar to booleans, in that they may be reduced into two values, ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),".\nSigmaProps enable the usage of Zero-Knowledge Proofs, an important part of modern-day cryptography and one of the defining features of Ergo in terms of its privacy"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"All contracts in ErgoScript return a Sigma Proposition at the very end"),". This SigmaProp represents the conditions needed\nto spend the box protected by your contract. For this reason, all the code you make within an ErgoScript contract should affect the outcome of your Sigma Proposition in some way."),(0,i.kt)("p",null,"SigmaProps come in a few different forms, but there are two main ways you will see them in ErgoScript contracts."),(0,i.kt)("h3",{id:"sigmaprops-from-booleans"},"SigmaProps From Booleans"),(0,i.kt)("p",null,"You may create SigmaProps from booleans using the ",(0,i.kt)("inlineCode",{parentName:"p"},"sigmaProp")," function. This\nallows you to define arbitrary spending conditions for any contract."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"{\n  val mathIsHard: Boolean = (1 + 1) != 2\n  sigmaProp(mathIsHard) // SigmaProp created from a boolean using the sigmaProp function\n                        // What would this contract evaluate to?\n}\n\n")),(0,i.kt)("h3",{id:"sigmaprops-from-public-keys"},"SigmaProps From Public Keys"),(0,i.kt)("p",null,"Public Keys (Essentially, the part of your address that makes it different from everyone else's)\nare also SigmaProps. When a public key is passed as a SigmaProp, your contract checks whether or not the given PK is the one that signed the transaction\nYou may think of signing a transaction, as quite literally signing it with your signature to prove\nthat the transaction was authorized by you."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'{\n  // You can use the PK function to\n  // hardcode an address\'s public key into your contract\n  val myPK: SigmaProp = PK("9etXmP7D3ZkWssDopWcWkCPpjn22RVuEyXoFSbVPWAvvzDbcDXE")\n\n  myPK\n}\n\n')),(0,i.kt)("h3",{id:"sigmaprop-operations"},"SigmaProp Operations"),(0,i.kt)("p",null,"Much like booleans, you may use logical operations on SigmaProps in order to build more complex spending logic for your contract"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'{\n  val enoughERG = INPUTS(0).value > 1000000\n  val myPK = PK("9etXmP7D3ZkWssDopWcWkCPpjn22RVuEyXoFSbVPWAvvzDbcDXE")\n\n  sigmaProp(enoughERG) || myPK // What does this contract do? Under what conditions could such a contract be spent?\n}\n\n')),(0,i.kt)("p",null,"You can see in the above contract that usage of ",(0,i.kt)("inlineCode",{parentName:"p"},"||")," actually creates two spending paths for the given contract."),(0,i.kt)("p",null,"Now you've seen the basics, for the end of this section, lets look at a simple ErgoScript contract, the pin-lock we mentioned earlier"),(0,i.kt)("h3",{id:"pin-lock-contract"},"Pin-lock Contract"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"{\n  sigmaProp( INPUTS(0).R4[Coll[Byte]].get == blake2b256(OUTPUTS(0).R4[Coll[Byte]].get) )\n}\n\n")),(0,i.kt)("p",null,"Don't worry if you don't understand the functions used here, these are global functions that we will get into the next section.\nWhat's happening here is this:"),(0,i.kt)("p",null,"We may spend Input 0 of this transaction if and only if there exists an output whose ",(0,i.kt)("inlineCode",{parentName:"p"},"R4")," (register 4)\ncontains the hash of the collection of bytes found in R4 of the Input.\nThis contract refers to itself as ",(0,i.kt)("inlineCode",{parentName:"p"},"INPUTS(0)"),", for a more clear example, look at the following, where the box being spent refers to itself within its own contract:"),(0,i.kt)("h3",{id:"pin-lock-contract-with-self"},"Pin-lock Contract (with SELF)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"{\n  sigmaProp( SELF.R4[Coll[Byte]].get == blake2b256(OUTPUTS(0).R4[Coll[Byte]].get) )\n}\n\n")),(0,i.kt)("p",null,"Are these two contracts equivalent?\nThat is, are there any spending conditions that exist in which one contract could evaluate to true, and one could evaluate to false?"),(0,i.kt)("h1",{id:"technical-knowledge"},"Technical Knowledge"),(0,i.kt)("h1",{id:"the-blockchain-context"},"The Blockchain Context"),(0,i.kt)("p",null,"The Blockchain Context represents data taken from the transaction and the state of the blockchain. The data for the blockchain context is stored in the global object ",(0,i.kt)("inlineCode",{parentName:"p"},"CONTEXT"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"CONTEXT"),", therefore, contains the main entities that you will interact with to manipulate your contract\u2019s spending conditions."),(0,i.kt)("h3",{id:"height"},"HEIGHT"),(0,i.kt)("p",null,"An integer representing the height of the current block is to be validated by miners. The number can be accessed using ",(0,i.kt)("inlineCode",{parentName:"p"},"HEIGHT"),"."),(0,i.kt)("h3",{id:"self"},"SELF"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SELF")," represents the current eUTxO input box which holds the ErgoScript contract. The SELF box is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Box"),", which contains information relevant to the specified eUTXO such as:"),(0,i.kt)("p",null,"the value in nanoERGs; the box id; the proposition bytes of the guarding script for this eUTXO, the tokens stored in the box; and the box registers."),(0,i.kt)("h3",{id:"inputs"},"INPUTS"),(0,i.kt)("p",null,"The eUTxOs are used as input boxes to be spent in the transaction. The boxes are stored in a collection and can be accessed using the object called ",(0,i.kt)("inlineCode",{parentName:"p"},"INPUTS"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"SELF")," box is part of this input box collection."),(0,i.kt)("h3",{id:"data-inputs"},"Data Inputs"),(0,i.kt)("p",null,"Data inputs are input eUTXOs that are not spent in the transaction. They serve as \u2018read-only\u2019 boxes, usually holding information necessary for the spending conditions of the contract. Data inputs can be accessed using ",(0,i.kt)("inlineCode",{parentName:"p"},"CONTEXT.dataInputs"),"."),(0,i.kt)("h3",{id:"outputs"},"OUTPUTS"),(0,i.kt)("p",null,"The output box eUTXOs will be created from the transaction. The collection can be accessed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"OUTPUTS")," object."),(0,i.kt)("h3",{id:"headers"},"Headers"),(0,i.kt)("p",null,"Block headers (Parts of each block that hold information representing the block) are available through the ",(0,i.kt)("inlineCode",{parentName:"p"},"CONTEXT.headers")," function. The ",(0,i.kt)("inlineCode",{parentName:"p"},"headers")," function returns a collection holding the last 10 block headers present before the current ",(0,i.kt)("inlineCode",{parentName:"p"},"HEIGHT"),". Using this function allows your contract to gain insight into the most recent blocks that occurred before the transaction that your contract is being executed in. Each ",(0,i.kt)("inlineCode",{parentName:"p"},"Header")," object in the collection returned by ",(0,i.kt)("inlineCode",{parentName:"p"},"headers")," holds a variety of different information, much of this information pertains to the block miner, such as the miner\u2019s PK, the nonce used to find the block, and the votes the miner submitted when the block was mined."),(0,i.kt)("h3",{id:"pre-headers"},"Pre-Headers"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"CONTEXT.preHeader")," function gives your contract access to the ",(0,i.kt)("inlineCode",{parentName:"p"},"PreHeader"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"PreHeader")," object represents all of the information available to miners who are working to find the next block. Because each block miner must insert their own information to properly mine a block, the data contained within each ",(0,i.kt)("inlineCode",{parentName:"p"},"PreHeader")," object is completely different depending on who mines the block. This means that your contract could execute differently depending on who ends up mining the block that spends your contract\u2019s box."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"{\n    // Don't worry about the fields accessed in our CONTEXT data, we will go more in depth\n    // in the next section. Instead focus on how we are accessing this data and then using\n    // using it in our contract.\n    val selfAtZero = SELF.id == INPUTS(0).id\n    val boxAmountToAdd: Long = CONTEXT.dataInputs(0).R4[Long].get // Get's a long from R4\n    val amountAddedInOutputs = OUTPUTS(0).value == SELF.value + boxAmountToAdd\n    val heightIsValid: Boolean = HEIGHT > 700000\n    val randomValueIsEven: Boolean = CONTEXT.headers(0).powNonce(0) % 2 == 0\n\n    sigmaProp(amountAddedInOutputs && selfAtZero)\n            || sigmaProp(heightIsValid && randomValueIsEven)\n}\n")),(0,i.kt)("h1",{id:"boxes-and-registers"},"Boxes and Registers"),(0,i.kt)("p",null,"Boxes are the main entity used to hold ERG according to the eUTXO model. Registers are pieces of data that can be attached to any box. They allow your contract to store data and incorporate it into transactions at a later point. There are 4 mandatory registers present within each box in the Ergo blockchain, these registers describe information that is necessary for a box to exist and be valid. Besides the mandatory registers, there are 5 additional registers that may store arbitrary data. This data could be obtained both off-chain and on-chain and allows you to incorporate more data when creating the spending conditions for your contract."),(0,i.kt)("h3",{id:"r0"},"R0"),(0,i.kt)("p",null,"Contains the monetary value of the box in nanoERGs. This register is accessed using ",(0,i.kt)("inlineCode",{parentName:"p"},"Box.value"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"Box")," could represent either ",(0,i.kt)("inlineCode",{parentName:"p"},"SELF")," or one of the boxes in the ",(0,i.kt)("inlineCode",{parentName:"p"},"INPUTS")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"OUTPUTS")," collection."),(0,i.kt)("h3",{id:"r1"},"R1"),(0,i.kt)("p",null,"Contains the collection of proposition bytes of the guarding ErgoScript contract for the box. It is accessed using ",(0,i.kt)("inlineCode",{parentName:"p"},"Box.propositionBytes"),"."),(0,i.kt)("h3",{id:"r2"},"R2"),(0,i.kt)("p",null,"Contains a collection of the tokens stored in the box. A token contains is represented by two pieces of information: the unique token id; and the amount of the specified token. The collection is accessed using ",(0,i.kt)("inlineCode",{parentName:"p"},"Box.tokens"),"."),(0,i.kt)("h3",{id:"r3"},"R3"),(0,i.kt)("p",null,"Contains information about the box\u2019s creation such as: the transaction id from which the box was created as an output; the outputs index of the box (i.e. the index used in ",(0,i.kt)("inlineCode",{parentName:"p"},"OUTPUTS"),"); and the creation height of the block of the transaction from which the box came from. This collection is accessed using ",(0,i.kt)("inlineCode",{parentName:"p"},"Box.creationInfo"),". The height referenced here is used as part of Ergo\u2019s unique storage rent feature, where boxes may be spent after 4 years so that miners may take some fee and recycle ERG back into the blockchain."),(0,i.kt)("h3",{id:"r4---r9"},"R4 - R9"),(0,i.kt)("p",null,"Contains arbitrary data that is set whenever the box is first outputted from a transaction. This data may essentially be any type commonly found in ErgoScript, along with more complex types built from Pairs and Collections. Registers may also store more complex types such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Box"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SigmaProp"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupElement"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"AVLTree"),"."),(0,i.kt)("h3",{id:"other-box-functions"},"Other Box Functions"),(0,i.kt)("p",null,"Outside of the registers themselves, each box has a specific identification hash that may be referenced using the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," function. Box ids are formed by taking the ",(0,i.kt)("inlineCode",{parentName:"p"},"blake2b256")," hash of the boxes content as a ",(0,i.kt)("inlineCode",{parentName:"p"},"Coll[Byte]")," . You may directly reference the un-hashed collection of bytes representing a box using the ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," function. Keep in mind that each box\u2019s content and id are cryptographically unique, meaning that no two boxes within the blockchain may have the same id or content bytes. This is achieved due to the inclusion of ",(0,i.kt)("inlineCode",{parentName:"p"},"creationInfo")," within each box, as transaction ids and associated output indexes are all values that must be unique to a given UTXO. You may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"bytesWithoutRef")," function to return a ",(0,i.kt)("inlineCode",{parentName:"p"},"Coll[Byte]")," that does not contain such information."),(0,i.kt)("h2",{id:"example-1"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'{\n    val valueMultiplier = SELF.R4[Int].get\n    val tokenMultiplier = INPUTS(1).R4[Int].get\n\n    if(SELF.id == INPUTS(0).id){\n        val outputValue = OUTPUTS(0).value == SELF.value * valueMultiplier\n        val outputTokens = OUTPUTS(0).tokens(0)._2 == SELF.value * tokenMultiplier\n        sigmaProp(outputValue && outputTokens)\n    }else{\n        val outputGoesToCheese = {\n            PK("9etXmP7D3ZkWssDopWcWkCPpjn22RVuEyXoFSbVPWAvvzDbcDXE").propBytes\n                == OUTPUTS(0).propositionBytes\n        }\n        sigmaProp(outputGoesToCheese)\n    }\n}\n')),(0,i.kt)("h1",{id:"global-functions"},"Global Functions"),(0,i.kt)("p",null,"There are a variety of global functions available to use in ErgoScript. Here we will go through some of the most commonly used functions, (besides ",(0,i.kt)("inlineCode",{parentName:"p"},"sigmaProp"),"). A complete reference for all global functions and types may be found in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/docs/LangSpec.md"},"ErgoScript LangSpec")," ."),(0,i.kt)("h2",{id:"logical-functions"},"Logical Functions"),(0,i.kt)("p",null,"Logical functions describe global functions used on booleans. These functions of course include operators such as ",(0,i.kt)("inlineCode",{parentName:"p"},"&&")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"||"),", but the following commonly used functions also exist."),(0,i.kt)("h3",{id:"allof"},"AllOf"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"allOf")," function takes a collection booleans and returns a boolean indicating whether or not all of the given booleans within the collection evaluate to true. It is equivalent to inserting ",(0,i.kt)("inlineCode",{parentName:"p"},"&&")," between each boolean in the collection."),(0,i.kt)("h3",{id:"anyof"},"AnyOf"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"anyOf")," function takes a collection of booleans and returns a boolean indicating whether or not at least one boolean within the entire collection evaluates to true. It is equivalent to inserting ",(0,i.kt)("inlineCode",{parentName:"p"},"||")," between each boolean in the collection."),(0,i.kt)("h3",{id:"xorof"},"XorOf"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"xorOf")," function takes a collection of booleans and applies the XOR operation between each boolean within the collection. Therefore, the ",(0,i.kt)("inlineCode",{parentName:"p"},"xorOf")," function returns true if an odd number of booleans within the collection evaluate to true. It returns false if an even number of booleans within the collection evaluate to true."),(0,i.kt)("h2",{id:"zero-knowledge-functions"},"Zero-Knowledge Functions"),(0,i.kt)("p",null,"Zero Knowledge functions are functions that may be used to evaluate SigmaProps with Zero-Knowledge needed to verify the truth of the SigmaProps given."),(0,i.kt)("h3",{id:"atleast"},"AtLeast"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"atLeast")," function takes an integer ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," and a collection of SigmaProps and returns whether ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," SigmaProps within the collection evaluate to true. All SigmaProps are evaluated with zero knowledge."),(0,i.kt)("h3",{id:"zkproof"},"ZKProof"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ZKProof")," function takes a block of code and evaluates all operations within the code with zero-knowledge scoping. This may be useful if some operations within your contract must be kept private. The code block used must not use any boolean operations to ensure zero-knowledge, and the entire block must evaluate into a single root SigmaProp."),(0,i.kt)("h2",{id:"cryptographic-functions"},"Cryptographic Functions"),(0,i.kt)("p",null,"Cryptographic functions are functions related to cryptography. Such functions include hashing, and calculation over ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupElement")," values."),(0,i.kt)("h3",{id:"blake2b256"},"Blake2b256"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"blake2b256")," takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"Coll[Byte]")," and returns a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Coll[Byte]")," hashed according to the Blake2b256 algorithm. The Blake2b256 algorithm is the main hashing algorithm used within Ergo. It is also incorporated as a part of the Autolykos PoW algorithm used to mine Ergo."),(0,i.kt)("h3",{id:"sha256"},"Sha256"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sha256")," takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"Coll[Byte]")," and returns a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Coll[Byte]")," hashed according to the SHA256 hashing function."),(0,i.kt)("h3",{id:"decodepoint"},"DecodePoint"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"decodePoint")," takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"Coll[Byte]")," representing a Group Element and converts it into the ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupElement")," type."),(0,i.kt)("h3",{id:"provedhtuple"},"ProveDHTuple"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"proveDHTuple")," takes four ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupElement")," values and constructs them into a public key represented by a SigmaProp according to the Diffie-Hellman signature protocol. This is useful for creating shared public keys in MultiSig and Ring Signature settings."),(0,i.kt)("h3",{id:"provedlog"},"ProveDLog"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"proveDlog")," takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupElement")," and creates a public key represented by a SigmaProp."),(0,i.kt)("h2",{id:"compile-time-functions"},"Compile-Time Functions"),(0,i.kt)("p",null,"Compile-Time functions are not evaluated during the spending of the script, instead these functions are used when compiling an ErgoScript contract into the native ErgoTree language. These functions all take Strings (which is not an actual ErgoScript type) and then convert these strings into some ErgoScript type during contract compilation. These values are stored directly within the contract and cannot change once the contract has been compiled."),(0,i.kt)("h3",{id:"frombase"},"FromBase"),(0,i.kt)("p",null,"Two functions, ",(0,i.kt)("inlineCode",{parentName:"p"},"fromBase64")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fromBase58")," take Strings of their respective base and convert them into a ",(0,i.kt)("inlineCode",{parentName:"p"},"Coll[Byte]")," at compile time."),(0,i.kt)("h3",{id:"pk"},"PK"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"PK")," function takes an address string (which is actually just a base58 encoded ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupElement")," with a network identifier prefix) and converts it into a SigmaProp public key at compile time. This is actually done using many of the functions listed above."),(0,i.kt)("h3",{id:"deserialize"},"Deserialize"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"deserialize[T]")," function takes a type parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," along with a base58 encoded String of binary data. The String value is converted into some value with ErgoScript type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," at compile time."),(0,i.kt)("h2",{id:"other-functions"},"Other Functions"),(0,i.kt)("h3",{id:"getvar"},"GetVar"),(0,i.kt)("h3",{id:"substconstants"},"SubstConstants"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"substConstants")," function has the following signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def substConstants[T](scriptBytes: Coll[Byte],\n positions: Coll[Int], newValues: Coll[T]): Coll[Byte]\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"getVar[T]")," takes type parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," along with some integer ",(0,i.kt)("inlineCode",{parentName:"p"},"tag")," and returns some Context Variable with the given type that is associated with the given ",(0,i.kt)("inlineCode",{parentName:"p"},"tag"),". Context Variables are specific off-chain variables that may be attached to any box at the time of transaction creation. Context variables allow for robust changes for certain parameters within your contract. It is especially useful for providing generic contracts that rely on off-chain information which may change between different spending transactions."),(0,i.kt)("p",null,"It allows a contract to construct another contract\u2019s propositional bytes using the given parameters. Because a contract\u2019s address is created using its contents, inputting different constants within a contract can change it\u2019s address(and therefore, the contract itself). This function allows for a contract of the same \u201ctemplate\u201d to be created using a new set of constants. In order to be used properly, one must provide a sample of the contract\u2019s propositional bytes(parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"scriptBytes"),"), along with the ",(0,i.kt)("inlineCode",{parentName:"p"},"positions")," at which certain constants of type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," must be replaced with the values in the ",(0,i.kt)("inlineCode",{parentName:"p"},"newValues")," parameter."),(0,i.kt)("h2",{id:"example-alcohol-sale-proxy-contract"},"Example: Alcohol Sale Proxy Contract"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"{\n    // ====== Alcohol Sale Proxy Contract Example ====== //\n\n    // Hard-coded constants expected at compile time are written in UpperCamelCase.\n\n    // INPUTS:\n    // license          = INPUTS(0)\n    // buyerProxyInputs = INPUTS - INPUTS(0)\n    //\n    // OUTPUTS:\n    // storeBox              = OUTPUTS(0)\n    // provincialSalesTaxBox = OUTPUTS(1)\n    // federalSalesTaxBox    = OUTPUTS(2)\n    // buyerWalletBox        = OUTPUTS(3)\n    // minerFeeBox           = OUTPUTS(4)\n    //\n    // (*) Note:\n    //           1. Mining fee box is always the last box in the set of OUTPUTS of a transaction,\n    //              I am just showing this for clarity, but it will not be accessed in this contract.\n  //           2. If there is any that change remains in the proxy,\n    //                          it is sent back to the buyer wallet.\n\n    // Contract variables\n  val buyerPK: SigmaProp          = PK(buyerPKString)\n    val buyerProxyInputs: Coll[Box] = INPUTS.filter({ (input: Box) => input.propositionBytes == SELF.propositionBytes })\n    val buyerAmount: Long           = buyerProxyInputs.fold(0L)({ (input: Box, acc: Long) => acc + input.value })\n    val provincialSalesTax: Long    = (AlcoholSaleAmount * ProvincialSalesTaxNum) / ProvincialSalesTaxDenom\n    val federalSalesTax: Long       = (AlcoholSaleAmount * FederalSalesTaxNum) / FederalSalesTaxDenom\n    val totalCost: Long             = AlcoholSaleAmount + provincialSalesTax + federalSalesTax + MinerFee\n\n// Variables associated with the buyer's license\n    val license = INPUTS(0)\n    val id      = license.R4[Coll[Byte]].get\n    val name    = license.R5[Coll[Byte]].get\n    val bDay    = license.R6[Coll[Byte]].get\n    val address = license.R7[Coll[Byte]].get\n    val expDate = license.R8[Coll[Byte]].get\n\n    // Context variables needed for the proxy contract, assuming they are provided correctly\n    val licenseTemplateContractBytes = getVar[Coll[Byte]](0).get\n\n    // Substitute the constants of the license template contract bytes\n    // and create the new contract bytes for the buyer's license\n    val newLicenseContractBytes = {\n\n        // New positions\n        val newPositions_SigmaProp: Coll[Int] = Coll(0)\n        val newPositions_Coll_Byte: Coll[Int] = Coll(1, 2, 3, 4, 5)\n\n        // New constants\n        val newConstants_SigmaProp: Coll[SigmaProp] = Coll(buyerPK)\n        val newConstants_Coll_Byte: Coll[Byte] = Coll(id, name, bDay, address, expDate)\n\n        // New contract bytes with substituted buyer PK\n        val newContractBytes_SigmaProp = substConstants(licenseTemplateContractBytes, newPositions_SigmaProp, newConstants_SigmaProp)\n\n        // New contract bytes with substituted buyer license information\n        val newContractBytes_Coll_Byte = substConstants(newContractBytes_SigmaProp, newPositions_Coll_Byte, newConstants_Coll_Byte)\n        val newContractBytes = newContractBytes_Coll_Byte\n\n        newContractBytes\n    }\n\n    // Check for a valid sale\n    val validSale = {\n\n        // Check for a valid license\n        val validLicense = {\n            allOf(Coll(\n                BuyerLicenseContractBytes == newLicenseContractBytes,\n                license.propositionBytes == newLicenseContractBytes\n            ))\n        }\n\n        // Check for a valid proxy amount\n    val validProxyAmount = {\n        buyerAmount >= totalAmount\n        }\n\n        // Check for a valid store\n        val validStore = {\n            val storeBox = OUTPUTS(0)\n            storeBox.propBytes == StoreBoxPropositionBytes\n        }\n\n        // Check for valid sales taxes\n        val validSalesTaxes = {\n\n            // Check for a valid provincial tax\n            val validProvincialSalesTax = {\n                val provincialSalesTaxBox = OUTPUTS(1)\n                allOf(Coll(\n                    (provincialSalesTaxBox.propositionBytes == ProvincialSalesTaxPK),\n                    (provincialSalesTaxBox.value >= provincialSalesTax)\n                ))\n            }\n\n            // Check for a valid federal tax\n            val validFederalSalesTax = {\n                val federalSalesTaxBox = OUTPUTS(2)\n                allOf(Coll(\n                    (federalSalesTaxBox.propositionBytes == FederalSalesTaxPK),\n                    (federalSalesTaxBox.value >= federalSalesTax)\n                ))\n            }\n\n      // Demand that both sales taxes are valid\n      allOf(Coll(\n        validProvincialSalesTax,\n        validFederalSalesTax\n      ))\n\n        }\n\n        // Check for a valid buyer wallet to return any change\n        val validBuyerWallet = {\n            if (buyerAmount > totalCost) {\n                val buyerWalletBox = OUTPUTS(3)\n                buyerWalletBox.propositionBytes == buyerPK.propBytes\n            } else {\n                true\n            }\n        }\n\n        // Demand that all the conditions are valid\n        allOf(Coll(\n            validLicense,\n            validProxyAmount,\n            validStore,\n            validSalesTaxes,\n            validBuyerWallet\n        ))\n\n    }\n\n    // Check for a valid refund\n    val validRefund = {\n        val refundWalletBox = OUTPUTS(0)\n        allOf(Coll(\n            (refundWalletBox.propositionBytes == buyerPK.propBytes),\n            (refundWalletBox.value >= buyerAmount - MinerFee)\n        ))\n    }\n\n    // Obtain the appropriate sigma proposition\n    sigmaProp(anyOf(Coll(\n        validSale,\n        validRefund\n    )))\n\n}\n")),(0,i.kt)("h3",{id:"helpful-article"},"Helpful article:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/docs/LangSpec.md"},"Ergo Lang Spec"))))}h.isMDXComponent=!0}}]);